// VEXON STANDARD LIBRARY (50 namespaces)
// Save as vexon_stdlib.vx
// Import with: import "vexon_stdlib.vx" as std

let std = {}

// ---------------------------
// 1. string
// ---------------------------
fn string_reverse(s) {
  let out = ""
  let i = len(s) - 1
  while (i >= 0) { out = out + s[i]; i = i - 1 }
  return out
}
fn string_capitalize(s) {
  if (len(s) == 0) return ""
  return toUpper(s[0]) + substring(s, 1)
}
fn string_repeat(s, n) {
  let out = ""; let i = 0
  while (i < n) { out = out + s; i = i + 1 }
  return out
}
std.string = {}
std.string.reverse = string_reverse
std.string.capitalize = string_capitalize
std.string.repeat = string_repeat

// ---------------------------
// 2. text
// ---------------------------
fn text_bold(s) { return "**" + s + "**" }
fn text_italic(s) { return "*" + s + "*" }
fn text_code(s) { return "`" + s + "`" }
std.text = {}
std.text.bold = text_bold
std.text.italic = text_italic
std.text.code = text_code

// ---------------------------
// 3. search
// ---------------------------
fn search_contains(s, sub) { return indexOf(s, sub) != -1 }
fn search_count(s, sub) {
  let c = 0; let i = 0
  while (i <= len(s)-len(sub)) {
    if (substring(s, i, i+len(sub)) == sub) c = c + 1
    i = i + 1
  }
  return c
}
std.search = {}
std.search.contains = search_contains
std.search.count = search_count

// ---------------------------
// 4. unicode
// ---------------------------
fn unicode_is_digit(c) { return c >= "0" && c <= "9" }
fn unicode_is_alpha(c) { return (c >= "a" && c <= "z") || (c >= "A" && c <= "Z") }
std.unicode = {}
std.unicode.is_digit = unicode_is_digit
std.unicode.is_alpha = unicode_is_alpha

// ---------------------------
// 5. parse
// ---------------------------
fn parse_bool(s) {
  let t = toLower(trim(s))
  if (t == "true") return true
  if (t == "false") return false
  return null
}
fn parse_csv(s) { return split(s, ",") }
std.parse = {}
std.parse.bool = parse_bool
std.parse.csv = parse_csv

// ---------------------------
// 6. array
// ---------------------------
fn array_sum(a) { let s = 0; for x in a s = s + x; return s }
fn array_avg(a) { if (len(a) == 0) return 0; return array_sum(a) / len(a) }
fn array_max(a) { if (len(a) == 0) return null; let m = a[0]; for x in a if x > m m = x; return m }
std.array = {}
std.array.sum = array_sum
std.array.avg = array_avg
std.array.max = array_max

// ---------------------------
// 7. list_ops
// ---------------------------
fn list_unique(a) {
  let out = []
  for x in a {
    let f = false
    for y in out if (x == y) f = true
    if (!f) push(out, x)
  }
  return out
}
fn list_find(a, v) {
  let i = 0
  while (i < len(a)) { if (a[i] == v) return i; i = i + 1 }
  return -1
}
std.list = {}
std.list.unique = list_unique
std.list.find = list_find

// ---------------------------
// 8. sort
// ---------------------------
fn sort_bubble(a) {
  let n = len(a); let i = 0
  while (i < n) {
    let j = 0
    while (j < n-1) {
      if (a[j] > a[j+1]) { let t = a[j]; a[j] = a[j+1]; a[j+1] = t }
      j = j + 1
    }
    i = i + 1
  }
  return a
}
std.sort = {}
std.sort.bubble = sort_bubble

// ---------------------------
// 9. stack
// ---------------------------
let _stack_internal = []
fn stack_push(v) { push(_stack_internal, v) }
fn stack_pop() { return pop(_stack_internal) }
fn stack_peek() { if (len(_stack_internal)==0) return null; return _stack_internal[len(_stack_internal)-1] }
std.stack = {}
std.stack.push = stack_push
std.stack.pop = stack_pop
std.stack.peek = stack_peek

// ---------------------------
// 10. queue
// ---------------------------
let _queue_internal = []
fn queue_enqueue(v) { push(_queue_internal, v) }
fn queue_dequeue() {
  if (len(_queue_internal) == 0) return null
  let out = _queue_internal[0]
  let i = 0
  while (i < len(_queue_internal)-1) { _queue_internal[i] = _queue_internal[i+1]; i = i + 1 }
  pop(_queue_internal)
  return out
}
std.queue = {}
std.queue.enqueue = queue_enqueue
std.queue.dequeue = queue_dequeue

// ---------------------------
// 11. math
// ---------------------------
fn math_clamp(x, a, b) { if (x < a) return a; if (x > b) return b; return x }
fn math_lerp(a, b, t) { return a + (b - a) * t }
fn math_sign(x) { if (x > 0) return 1; if (x < 0) return -1; return 0 }
std.mathx = {}
std.mathx.clamp = math_clamp
std.mathx.lerp = math_lerp
std.mathx.sign = math_sign

// ---------------------------
// 12. geometry
// ---------------------------
fn geom_dist(x1,y1,x2,y2) { let dx=x2-x1; let dy=y2-y1; return math.sqrt(dx*dx + dy*dy) }
fn geom_area_rect(w,h) { return w * h }
std.geometry = {}
std.geometry.dist = geom_dist
std.geometry.area_rect = geom_area_rect

// ---------------------------
// 13. vector2
// ---------------------------
fn v2_add(a, b) { return {x: a.x + b.x, y: a.y + b.y} }
fn v2_sub(a, b) { return {x: a.x - b.x, y: a.y - b.y} }
fn v2_scale(a, s) { return {x: a.x * s, y: a.y * s} }
std.vector2 = {}
std.vector2.add = v2_add
std.vector2.sub = v2_sub
std.vector2.scale = v2_scale

// ---------------------------
// 14. fs
// ---------------------------
fn fs_read_lines(p) {
  if (!exists(p)) return []
  return split(read(p), "\n")
}
fn fs_write_lines(p, arr) {
  let s = ""
  for x in arr s = s + x + "\n"
  write(p, s)
}
fn fs_copy(a,b) { write(b, read(a)) }
std.fs = {}
std.fs.read_lines = fs_read_lines
std.fs.write_lines = fs_write_lines
std.fs.copy = fs_copy

// ---------------------------
// 15. time
// ---------------------------
fn time_now() { return time() }
fn time_sleep_ms(ms) { sleep(ms); return null }
fn time_ts() { return toString(time()) }
std.time = {}
std.time.now = time_now
std.time.sleep_ms = time_sleep_ms
std.time.ts = time_ts

// ---------------------------
// 16. random
// ---------------------------
fn rnd_int(min, max) { return floor(random() * (max - min + 1)) + min }
fn rnd_choice(a) { if (len(a)==0) return null; return a[rnd_int(0, len(a)-1)] }
fn rnd_shuffle(a) {
  let i = len(a)-1
  while (i > 0) {
    let j = rnd_int(0, i)
    let t = a[i]; a[i] = a[j]; a[j] = t
    i = i - 1
  }
  return a
}
std.random = {}
std.random.randint = rnd_int
std.random.choice = rnd_choice
std.random.shuffle = rnd_shuffle

// ---------------------------
// 17. log
// ---------------------------
fn log_write(m) { append("vexon.log", "[" + toString(time()) + "] " + m + "\n") }
fn log_read_all() { if (!exists("vexon.log")) return ""; return read("vexon.log") }
fn log_clear() { write("vexon.log", "") }
std.log = {}
std.log.write = log_write
std.log.read = log_read_all
std.log.clear = log_clear

// ---------------------------
// 18. env
// ---------------------------
fn env_get(n) { return env(n) }
fn env_set(n,v) { set_env(n, v); return null }
std.env = {}
std.env.get = env_get
std.env.set = env_set

// ---------------------------
// 19. json
// ---------------------------
fn json_enc(o) { return json_encode(o) }
fn json_dec(s) { return json_decode(s) }
fn json_save(p,o) { write(p, json_encode(o)); return null }
fn json_load(p) { return json_decode(read(p)) }
std.json = {}
std.json.encode = json_enc
std.json.decode = json_dec
std.json.save = json_save
std.json.load = json_load

// ---------------------------
// 20. path
// ---------------------------
fn path_join(a,b) { return join_path(a,b) }
fn path_filename(p) {
  let arr = split(p, "/"); return arr[len(arr)-1]
}
fn path_ext(p) {
  let arr = split(p, "."); if (len(arr)<2) return ""; return arr[len(arr)-1]
}
std.path = {}
std.path.join = path_join
std.path.filename = path_filename
std.path.ext = path_ext

// ---------------------------
// 21. http (wrapper)
// ---------------------------
fn http_get_json(url) { return http_get(url) }
fn http_post_json(url, payload) { return http_post(url, payload) }
std.http = {}
std.http.get = http_get_json
std.http.post = http_post_json

// ---------------------------
// 22. net (tiny helpers)
// ---------------------------
fn net_ping(url) {
  // simple: try GET and return truthy if succeeds
  try {
    let r = http_get(url)
    return true
  } catch (e) {
    return false
  }
}
std.net = {}
std.net.ping = net_ping

// ---------------------------
// 23. base64 (simple)
// ---------------------------
fn b64_encode_js(s) {
  // attempt: use Buffer via exec if available; fallback simple map (not robust)
  try {
    let out = exec("node -e \"console.log(Buffer.from(" + JSON.stringify(s) + ").toString('base64'))\"")
    return out
  } catch (e) {
    // fallback naive (not binary safe)
    let chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    let out = ""
    let i = 0
    while (i < len(s)) {
      out = out + s[i]
      i = i + 1
    }
    return out
  }
}
std.base64 = {}
std.base64.encode = b64_encode_js

// ---------------------------
// 24. uuid (very simple)
// ---------------------------
fn uuid_v4_like() {
  let a = ""
  let i = 0
  while (i < 32) {
    let n = rnd_int(0,15)
    let h = "0123456789abcdef"[n]
    a = a + h
    i = i + 1
  }
  return substring(a,0,8) + "-" + substring(a,8,12) + "-" + substring(a,12,16) + "-" + substring(a,16,20) + "-" + substring(a,20,32)
}
std.uuid = {}
std.uuid.v4 = uuid_v4_like

// ---------------------------
// 25. csv
// ---------------------------
fn csv_parse(text) {
  let lines = split(text, "\n")
  let out = []
  for l in lines {
    if (len(trim(l)) == 0) continue
    push(out, split(l, ","))
  }
  return out
}
fn csv_stringify(arr) {
  let out = ""
  for r in arr { let i = 0; let line = ""; while (i < len(r)) { line = line + toString(r[i]) + (i < len(r)-1 ? "," : ""); i = i + 1 } out = out + line + "\n" }
  return out
}
std.csv = {}
std.csv.parse = csv_parse
std.csv.stringify = csv_stringify

// ---------------------------
// 26. validators
// ---------------------------
fn is_email(s) {
  return indexOf(s, "@") != -1 && indexOf(s, ".") != -1
}
fn is_url(s) {
  return startsWith(s, "http://") || startsWith(s, "https://")
}
std.validators = {}
std.validators.email = is_email
std.validators.url = is_url

// ---------------------------
// 27. stopwatch
// ---------------------------
fn sw_start() { return time() }
fn sw_elapsed(start) { return time() - start }
std.stopwatch = {}
std.stopwatch.start = sw_start
std.stopwatch.elapsed = sw_elapsed

// ---------------------------
// 28. stats
// ---------------------------
fn stats_mean(a) { if (len(a)==0) return null; return array_sum(a) / len(a) }
fn stats_variance(a) {
  let m = stats_mean(a)
  if (m == null) return null
  let s = 0
  for x in a s = s + (x - m) * (x - m)
  return s / len(a)
}
std.stats = {}
std.stats.mean = stats_mean
std.stats.variance = stats_variance

// ---------------------------
// 29. matrix (basic)
// ---------------------------
fn mat_mul_vec(mat, vec) {
  let out = []
  let i = 0
  while (i < len(mat)) {
    let row = mat[i]; let s = 0; let j = 0
    while (j < len(row)) { s = s + row[j] * vec[j]; j = j + 1 }
    push(out, s); i = i + 1
  }
  return out
}
std.matrix = {}
std.matrix.mul_vec = mat_mul_vec

// ---------------------------
// 30. data (key-value simple db)
// ---------------------------
fn kv_set(path, key, val) {
  let store = {}
  if (exists(path)) store = json_decode(read(path))
  store[key] = val
  write(path, json_encode(store))
  return null
}
fn kv_get(path, key) {
  if (!exists(path)) return null
  let store = json_decode(read(path))
  return store[key]
}
std.kv = {}
std.kv.set = kv_set
std.kv.get = kv_get

// ---------------------------
// 31. serializer (tiny)
// ---------------------------
fn ser_to_json(o) { return json_encode(o) }
fn ser_from_json(s) { return json_decode(s) }
std.serializer = {}
std.serializer.to_json = ser_to_json
std.serializer.from_json = ser_from_json

// ---------------------------
// 32. html_utils
// ---------------------------
fn html_escape(s) {
  let out = s
  out = replace(out, "&", "&amp;")
  out = replace(out, "<", "&lt;")
  out = replace(out, ">", "&gt;")
  out = replace(out, "\"", "&quot;")
  return out
}
std.html = {}
std.html.escape = html_escape

// ---------------------------
// 33. shell (exec helpers)
// ---------------------------
fn sh_exec(cmd) {
  return exec(cmd)
}
fn sh_capture(cmd) {
  return exec(cmd)
}
std.shell = {}
std.shell.exec = sh_exec
std.shell.capture = sh_capture

// ---------------------------
// 34. colors (basic)
// ---------------------------
fn color_hex_to_rgb(hex) {
  if (startsWith(hex, "#")) hex = substring(hex, 1)
  let r = parseInt(substring(hex,0,2),16)
  let g = parseInt(substring(hex,2,4),16)
  let b = parseInt(substring(hex,4,6),16)
  return {r: r, g: g, b: b}
}
std.color = {}
std.color.hex_to_rgb = color_hex_to_rgb

// ---------------------------
// 35. terminal (tiny styling)
// ---------------------------
fn term_clear() {
  // best-effort clear
  try { exec("clear") } catch (e) { try { exec("cls") } catch (e2) {} }
  return null
}
std.terminal = {}
std.terminal.clear = term_clear

// ---------------------------
// 36. scheduler (very simple)
// ---------------------------
fn schedule_sleep_then(ms, fnname) {
  sleep(ms)
  // call global function by name if exists
  let f = global_get(fnname)
  if (f) f()
  return null
}
std.scheduler = {}
std.scheduler.sleep_then = schedule_sleep_then

// ---------------------------
// 37. compression (placeholder)
// ---------------------------
fn compress_stub(s) { return s } // no real compression here
fn decompress_stub(s) { return s }
std.compress = {}
std.compress.compress = compress_stub
std.compress.decompress = decompress_stub

// ---------------------------
// 38. encoding (utf helpers)
// ---------------------------
fn enc_upper(s) { return toUpper(s) }
fn enc_lower(s) { return toLower(s) }
std.encoding = {}
std.encoding.upper = enc_upper
std.encoding.lower = enc_lower

// ---------------------------
// 39. math_more
// ---------------------------
fn mm_factorial(n) {
  if (n <= 1) return 1
  let r = 1; let i = 2
  while (i <= n) { r = r * i; i = i + 1 }
  return r
}
std.math_more = {}
std.math_more.factorial = mm_factorial

// ---------------------------
// 40. geometry3d (basic)
// ---------------------------
fn g3d_dist(x1,y1,z1,x2,y2,z2) {
  let dx = x2-x1; let dy = y2-y1; let dz = z2-z1
  return math.sqrt(dx*dx + dy*dy + dz*dz)
}
std.geometry3d = {}
std.geometry3d.dist = g3d_dist

// ---------------------------
// 41. physics_basic
// ---------------------------
fn physics_kinematic_pos(x0, v, t) { return x0 + v * t }
std.physics = {}
std.physics.kinematic_pos = physics_kinematic_pos

// ---------------------------
// 42. game_loop (very small)
// ---------------------------
fn game_loop_simple(iterations, tick_ms, body_fn_name) {
  let i = 0
  while (i < iterations) {
    let f = global_get(body_fn_name)
    if (f) f(i)
    sleep(tick_ms)
    i = i + 1
  }
  return null
}
std.gameloop = {}
std.gameloop.simple = game_loop_simple

// ---------------------------
// 43. io_helpers
// ---------------------------
fn io_exists(p) { return exists(p) }
fn io_delete(p) { delete(p); return null }
std.io = {}
std.io.exists = io_exists
std.io.delete = io_delete

// ---------------------------
// 44. html_builder
// ---------------------------
fn hb_tag(name, content) { return "<" + name + ">" + content + "</" + name + ">" }
std.html_builder = {}
std.html_builder.tag = hb_tag

// ---------------------------
// 45. color_utils
// ---------------------------
fn color_brightness(hex) {
  let c = color_hex_to_rgb(hex)
  return (c.r*299 + c.g*587 + c.b*114) / 1000
}
std.color_utils = {}
std.color_utils.brightness = color_brightness

// ---------------------------
// 46. simple_ai (toy)
// ---------------------------
fn ai_echo(s) { return "ECHO: " + s }
std.ai = {}
std.ai.echo = ai_echo

// ---------------------------
// 47. phone (formatting)
// ---------------------------
fn phone_digits(s) { return std.parse.csv(s) } // placeholder
std.phone = {}
std.phone.digits = phone_digits

// ---------------------------
// 48. zstring (zero-pad)
// ---------------------------
fn zpad(n, width) {
  let s = toString(n)
  while (len(s) < width) s = "0" + s
  return s
}
std.zstring = {}
std.zstring.pad = zpad

// ---------------------------
// 49. misc
// ---------------------------
fn misc_now_readable() { return toString(time()) }
std.misc = {}
std.misc.now = misc_now_readable

// ---------------------------
// 50. dev_helpers
// ---------------------------
fn dev_print_keys(o) {
  if (!o) return []
  return keys(o)
}
std.dev = {}
std.dev.keys = dev_print_keys

// Return std as module export
std
