// vexon_stdlib_fixed_v2.vx
// Vexon standard library (50 namespaces) â€” updated and cleaned for the new Vexon runtime
// - Conservative: avoids unsupported syntax and uses fallbacks for missing builtins
// - Defensive: checks for null/exists and traps exceptions
// - Registers `std` globally when possible and exports `std` at the end
// Usage: import "vexon_stdlib_fixed_v2.vx" as std

let std = {}

// ---- helpers ------------------------------------------------------------
fn _to_string(x) {
  try {
    return json_encode(x)
  } catch (e) {
    return "" + x
  }
}

fn _trim(s) {
  if s == null { return "" }
  let out = s
  // trim start
  while (len(out) > 0 && substring(out, 0, 1) == " ") {
    out = substring(out, 1)
  }
  // trim end
  while (len(out) > 0 && substring(out, len(out) - 1, 1) == " ") {
    out = substring(out, 0, len(out) - 1)
  }
  return out
}

fn _floor(x) {
  if x == null { return 0 }
  try {
    return parseInt(x)
  } catch (e) {
    // fallback: emulate floor for finite numbers
    try {
      if x >= 0 { return x - (x % 1) }
      // for negative numbers, truncation differs from floor; adjust
      let t = x - (x % 1)
      if t == x { return t }
      return t - 1
    } catch (e2) {
      return x
    }
  }
}

fn _sqrt(x) {
  if x == null { return 0 }
  if x <= 0 { return 0 }
  let g = x
  let i = 0
  while (i < 20) {
    let ng = (g + x / g) / 2
    g = ng
    i = i + 1
  }
  return g
}

fn _exec_get_stdout(cmd) {
  if cmd == null { return null }
  try {
    let r = exec(cmd)
    if r == null { return null }
    // r may be string or object
    try {
      if typeof(r) == "object" {
        if r.stdout != null { return r.stdout }
        if r["stdout"] != null { return r["stdout"] }
        if r.out != null { return r.out }
        try { return json_encode(r) } catch (e2) { return null }
      }
    } catch (ee) { /* ignore */ }
    return r
  } catch (e) {
    return null
  }
}

fn _sleep_ms(ms) {
  try {
    sleep(ms)
    return null
  } catch (e) {
    let start = time()
    while ((time() - start) < ms) { }
    return null
  }
}

// stable array helpers
fn _arr_push(a, v) {
  if a == null { return null }
  try {
    append(a, v)
    return null
  } catch (e) {
    try {
      push(a, v)
      return null
    } catch (e2) {
      // fallback: rebuild
      let out = []
      for x in a { append(out, x) }
      append(out, v)
      while (len(a) > 0) { try { pop(a) } catch (ee) { break } }
      for x in out { append(a, x) }
      return null
    }
  }
}

fn _arr_pop(a) {
  if a == null { return null }
  try {
    return pop(a)
  } catch (e) {
    if len(a) == 0 { return null }
    let last = a[len(a) - 1]
    let out = []
    let i = 0
    while (i < len(a) - 1) {
      append(out, a[i])
      i = i + 1
    }
    while (len(a) > 0) { try { pop(a) } catch (ee) { break } }
    for x in out { append(a, x) }
    return last
  }
}

// ---- 1 string ----------------------------------------------------------
std.string = {}
fn string_reverse(s) {
  if s == null { return "" }
  let out = ""
  let i = len(s) - 1
  while (i >= 0) {
    out = out + substring(s, i, 1)
    i = i - 1
  }
  return out
}
fn string_capitalize(s) {
  if s == null { return "" }
  if len(s) == 0 { return "" }
  let first = substring(s, 0, 1)
  let rest = ""
  if len(s) > 1 { rest = substring(s, 1) }
  try { return toUpper(first) + rest } catch (e) { return _to_string(first) + rest }
}
fn string_repeat(s, n) {
  if s == null { return "" }
  if n == null || n <= 0 { return "" }
  let out = ""
  let i = 0
  while (i < n) { out = out + s; i = i + 1 }
  return out
}
std.string.reverse = string_reverse
std.string.capitalize = string_capitalize
std.string.repeat = string_repeat

// ---- 2 text ------------------------------------------------------------
std.text = {}
fn text_bold(s) { if s == null { return "" } return "**" + s + "**" }
fn text_italic(s) { if s == null { return "" } return "*" + s + "*" }
fn text_code(s) { if s == null { return "" } return "`" + s + "`" }
std.text.bold = text_bold
std.text.italic = text_italic
std.text.code = text_code

// ---- 3 search ----------------------------------------------------------
std.search = {}
fn search_contains(s, sub) { if s == null || sub == null { return false } return indexOf(s, sub) != -1 }
fn search_count(s, sub) {
  if s == null || sub == null { return 0 }
  let c = 0
  let i = 0
  let ls = len(s)
  let lsub = len(sub)
  if lsub == 0 { return 0 }
  let limit = ls - lsub
  if limit < 0 { return 0 }
  while (i <= limit) {
    if substring(s, i, lsub) == sub { c = c + 1 }
    i = i + 1
  }
  return c
}
std.search.contains = search_contains
std.search.count = search_count

// ---- 4 unicode ---------------------------------------------------------
std.unicode = {}
fn unicode_is_digit(c) { if c == null { return false } return c >= "0" && c <= "9" }
fn unicode_is_alpha(c) { if c == null { return false } return (c >= "a" && c <= "z") || (c >= "A" && c <= "Z") }
std.unicode.is_digit = unicode_is_digit
std.unicode.is_alpha = unicode_is_alpha

// ---- 5 parse -----------------------------------------------------------
std.parse = {}
fn parse_bool(s) {
  if s == null { return null }
  let t = toLower(_trim(s))
  if t == "true" { return true }
  if t == "false" { return false }
  return null
}
fn parse_csv(s) { if s == null { return [] } return split(s, ",") }
std.parse.bool = parse_bool
std.parse.csv = parse_csv

// ---- 6 array -----------------------------------------------------------
std.array = {}
fn array_sum(a) { if a == null { return 0 } let s = 0; for x in a { s = s + x } return s }
fn array_avg(a) { if a == null { return 0 } if len(a) == 0 { return 0 } return array_sum(a) / len(a) }
fn array_max(a) { if a == null || len(a) == 0 { return null } let m = a[0]; for x in a { if x > m { m = x } } return m }
std.array.sum = array_sum
std.array.avg = array_avg
std.array.max = array_max

// ---- 7 list_ops --------------------------------------------------------
std.list = {}
fn list_unique(a) {
  if a == null { return [] }
  let out = []
  for x in a {
    let f = false
    for y in out { if x == y { f = true; break } }
    if !f { append(out, x) }
  }
  return out
}
fn list_find(a, v) { if a == null { return -1 } let i = 0; while (i < len(a)) { if a[i] == v { return i } i = i + 1 } return -1 }
std.list.unique = list_unique
std.list.find = list_find

// ---- 8 sort ------------------------------------------------------------
std.sort = {}
fn sort_bubble(a) {
  if a == null { return [] }
  let n = len(a)
  let i = 0
  while (i < n) {
    let j = 0
    while (j < n - 1) {
      if a[j] > a[j + 1] {
        let t = a[j]
        a[j] = a[j + 1]
        a[j + 1] = t
      }
      j = j + 1
    }
    i = i + 1
  }
  return a
}
std.sort.bubble = sort_bubble

// ---- 9 stack -----------------------------------------------------------
std.stack = {}
let _stack_internal = []
fn stack_push(v) { _arr_push(_stack_internal, v); return null }
fn stack_pop() { if len(_stack_internal) == 0 { return null } return _arr_pop(_stack_internal) }
fn stack_peek() { if len(_stack_internal) == 0 { return null } return _stack_internal[len(_stack_internal) - 1] }
std.stack.push = stack_push
std.stack.pop = stack_pop
std.stack.peek = stack_peek

// ---- 10 queue ----------------------------------------------------------
std.queue = {}
let _queue_internal = []
fn queue_enqueue(v) { _arr_push(_queue_internal, v); return null }
fn queue_dequeue() {
  if len(_queue_internal) == 0 { return null }
  let out = _queue_internal[0]
  let newarr = []
  let i = 1
  while (i < len(_queue_internal)) { append(newarr, _queue_internal[i]); i = i + 1 }
  while (len(_queue_internal) > 0) { _arr_pop(_queue_internal) }
  for x in newarr { append(_queue_internal, x) }
  return out
}
std.queue.enqueue = queue_enqueue
std.queue.dequeue = queue_dequeue

// ---- 11 math -----------------------------------------------------------
std.mathx = {}
fn math_clamp(x, a, b) { if x < a { return a } if x > b { return b } return x }
fn math_lerp(a, b, t) { return a + (b - a) * t }
fn math_sign(x) { if x > 0 { return 1 } if x < 0 { return -1 } return 0 }
std.mathx.clamp = math_clamp
std.mathx.lerp = math_lerp
std.mathx.sign = math_sign

// ---- 12 geometry -------------------------------------------------------
std.geometry = {}
fn geom_dist(x1, y1, x2, y2) { let dx = x2 - x1; let dy = y2 - y1; return _sqrt(dx * dx + dy * dy) }
fn geom_area_rect(w, h) { return w * h }
std.geometry.dist = geom_dist
std.geometry.area_rect = geom_area_rect

// ---- 13 vector2 --------------------------------------------------------
std.vector2 = {}
fn v2_add(a, b) { if a == null || b == null { return {x:0,y:0} } return { x: a.x + b.x, y: a.y + b.y } }
fn v2_sub(a, b) { if a == null || b == null { return {x:0,y:0} } return { x: a.x - b.x, y: a.y - b.y } }
fn v2_scale(a, s) { if a == null { return {x:0,y:0} } return { x: a.x * s, y: a.y * s } }
std.vector2.add = v2_add
std.vector2.sub = v2_sub
std.vector2.scale = v2_scale

// ---- 14 fs -------------------------------------------------------------
std.fs = {}
fn fs_read_lines(p) { if p == null { return [] } if !exists(p) { return [] } let txt = read(p); if txt == null { return [] } return split(txt, "\n") }
fn fs_write_lines(p, arr) { if arr == null { return null } let s = ""; for x in arr { s = s + _to_string(x) + "\n" } write(p, s); return null }
fn fs_copy(a, b) { if a == null || b == null { return null } if !exists(a) { return null } write(b, read(a)); return null }
std.fs.read_lines = fs_read_lines
std.fs.write_lines = fs_write_lines
std.fs.copy = fs_copy

// ---- 15 time -----------------------------------------------------------
std.time = {}
fn time_now() { return time() }
fn time_sleep_ms(ms) { _sleep_ms(ms); return null }
fn time_ts() { return _to_string(time()) }
std.time.now = time_now
std.time.sleep_ms = time_sleep_ms
std.time.ts = time_ts

// ---- 16 random ---------------------------------------------------------
std.random = {}
fn rnd_int(min, max) {
  if min > max { let t = min; min = max; max = t }
  let r = random()
  let range = max - min + 1
  let v = _floor(r * range)
  return min + v
}
fn rnd_choice(a) { if a == null || len(a) == 0 { return null } return a[rnd_int(0, len(a) - 1)] }
fn rnd_shuffle(a) { if a == null { return [] } let i = len(a) - 1; while (i > 0) { let j = rnd_int(0, i); let t = a[i]; a[i] = a[j]; a[j] = t; i = i - 1 } return a }
std.random.randint = rnd_int
std.random.choice = rnd_choice
std.random.shuffle = rnd_shuffle

// ---- 17 log ------------------------------------------------------------
std.log = {}
fn log_write(m) { if m == null { m = "" } append("vexon.log", "[" + _to_string(time()) + "] " + _to_string(m) + "\n"); return null }
fn log_read_all() { if !exists("vexon.log") { return "" } return read("vexon.log") }
fn log_clear() { write("vexon.log", ""); return null }
std.log.write = log_write
std.log.read = log_read_all
std.log.clear = log_clear

// ---- 18 env ------------------------------------------------------------
std.env = {}
fn env_get(n) { if n == null { try { return env() } catch (e) { return null } } try { return env(n) } catch (e) { return null } }
fn env_set(n, v) { if n == null { return null } try { set_env(n, v) } catch (e) { } return null }
std.env.get = env_get
std.env.set = env_set

// ---- 19 json -----------------------------------------------------------
std.json = {}
fn json_enc(o) { try { return json_encode(o) } catch (e) { return _to_string(o) } }
fn json_dec(s) { try { return json_decode(s) } catch (e) { return null } }
fn json_save(p, o) { if p == null { return null } write(p, json_enc(o)); return null }
fn json_load(p) { if p == null || !exists(p) { return null } return json_dec(read(p)) }
std.json.encode = json_enc
std.json.decode = json_dec
std.json.save = json_save
std.json.load = json_load

// ---- 20 path -----------------------------------------------------------
std.path = {}
fn path_join(a, b) { try { return join_path(a, b) } catch (e) { if a == null { return b } if b == null { return a } if endsWith(a, "/") { return a + b } return a + "/" + b } }
fn path_filename(p) { if p == null { return "" } let p2 = replace(p, "\\\\", "/"); let arr = split(p2, "/"); return arr[len(arr) - 1] }
fn path_ext(p) { if p == null { return "" } let n = path_filename(p); if indexOf(n, ".") == -1 { return "" } let parts = split(n, "."); return parts[len(parts) - 1] }
std.path.join = path_join
std.path.filename = path_filename
std.path.ext = path_ext

// ---- 21 http (wrappers) ------------------------------------------------
std.http = {}
fn http_get_json(url) { if url == null { return null } try { return http_get(url) } catch (e) { return null } }
fn http_post_json(url, payload) { if url == null { return null } try { return http_post(url, payload) } catch (e) { return null } }
std.http.get = http_get_json
std.http.post = http_post_json

// ---- 22 net ------------------------------------------------------------
std.net = {}
fn net_ping(url) { if url == null { return false } try { http_get(url); return true } catch (e) { return false } }
std.net.ping = net_ping

// ---- 23 base64 ---------------------------------------------------------
std.base64 = {}
fn b64_encode_js(s) { if s == null { return null } try { let cmd = "node -e \"console.log(Buffer.from(" + json_encode(s) + ").toString('base64'))\""; let out = _exec_get_stdout(cmd); return _trim(out) } catch (e) { return null } }
std.base64.encode = b64_encode_js

// ---- 24 uuid -----------------------------------------------------------
std.uuid = {}
fn uuid_v4_like() {
  let a = ""
  let i = 0
  while (i < 32) {
    let n = rnd_int(0, 15)
    let h = "0123456789abcdef"
    a = a + substring(h, n, 1)
    i = i + 1
  }
  return substring(a, 0, 8) + "-" + substring(a, 8, 4) + "-" + substring(a, 12, 4) + "-" + substring(a, 16, 4) + "-" + substring(a, 20, 12)
}
std.uuid.v4 = uuid_v4_like

// ---- 25 csv ------------------------------------------------------------
std.csv = {}
fn csv_parse(text) { if text == null { return [] } let lines = split(text, "\n"); let out = []; for l in lines { if len(_trim(l)) == 0 { continue } append(out, split(l, ",")) } return out }
fn csv_stringify(arr) { if arr == null { return "" } let out = ""; for r in arr { let i = 0; let line = ""; while (i < len(r)) { line = line + _to_string(r[i]); if i < len(r) - 1 { line = line + "," } i = i + 1 } out = out + line + "\n" } return out }
std.csv.parse = csv_parse
std.csv.stringify = csv_stringify

// ---- 26 validators -----------------------------------------------------
std.validators = {}
fn is_email(s) { if s == null { return false } return indexOf(s, "@") != -1 && indexOf(s, ".") != -1 }
fn is_url(s) { if s == null { return false } return startsWith(s, "http://") || startsWith(s, "https://") }
std.validators.email = is_email
std.validators.url = is_url

// ---- 27 stopwatch ------------------------------------------------------
std.stopwatch = {}
fn sw_start() { return time() }
fn sw_elapsed(start) { if start == null { return 0 } return time() - start }
std.stopwatch.start = sw_start
std.stopwatch.elapsed = sw_elapsed

// ---- 28 stats ----------------------------------------------------------
std.stats = {}
fn stats_mean(a) { if a == null || len(a) == 0 { return null } return array_sum(a) / len(a) }
fn stats_variance(a) { let m = stats_mean(a); if m == null { return null } let s = 0; for x in a { s = s + (x - m) * (x - m) } return s / len(a) }
std.stats.mean = stats_mean
std.stats.variance = stats_variance

// ---- 29 matrix ---------------------------------------------------------
std.matrix = {}
fn mat_mul_vec(mat, vec) { if mat == null || vec == null { return [] } let out = []; let i = 0; while (i < len(mat)) { let row = mat[i]; let s = 0; let j = 0; while (j < len(row)) { s = s + row[j] * vec[j]; j = j + 1 } append(out, s); i = i + 1 } return out }
std.matrix.mul_vec = mat_mul_vec

// ---- 30 data (kv simple) ------------------------------------------------
std.kv = {}
fn kv_set(path, key, val) { if path == null { return null } let store = {}; if exists(path) { store = json_decode(read(path)) } store[key] = val; write(path, json_encode(store)); return null }
fn kv_get(path, key) { if path == null || !exists(path) { return null } let store = json_decode(read(path)); return store[key] }
std.kv.set = kv_set
std.kv.get = kv_get

// ---- 31 serializer -----------------------------------------------------
std.serializer = {}
fn ser_to_json(o) { return json_encode(o) }
fn ser_from_json(s) { return json_decode(s) }
std.serializer.to_json = ser_to_json
std.serializer.from_json = ser_from_json

// ---- 32 html_utils -----------------------------------------------------
std.html = {}
fn html_escape(s) { if s == null { return "" } let out = s; out = replace(out, "&", "&amp;"); out = replace(out, "<", "&lt;"); out = replace(out, ">", "&gt;"); out = replace(out, '"', "&quot;"); return out }
std.html.escape = html_escape

// ---- 33 shell ----------------------------------------------------------
std.shell = {}
fn sh_exec(cmd) { if cmd == null { return null } try { return exec(cmd) } catch (e) { return null } }
fn sh_capture(cmd) { if cmd == null { return null } try { return _exec_get_stdout(cmd) } catch (e) { return null } }
std.shell.exec = sh_exec
std.shell.capture = sh_capture

// ---- 34 colors ---------------------------------------------------------
std.color = {}
fn color_hex_to_rgb(hex) { if hex == null { return {r:0,g:0,b:0} } let h = hex; if startsWith(h, "#") { h = substring(h, 1) } if len(h) < 6 { return { r: 0, g: 0, b: 0 } } let r = parseInt(substring(h, 0, 2), 16); let g = parseInt(substring(h, 2, 2), 16); let b = parseInt(substring(h, 4, 2), 16); return { r: r, g: g, b: b } }
std.color.hex_to_rgb = color_hex_to_rgb

// ---- 35 terminal -------------------------------------------------------
std.terminal = {}
fn term_clear() { try { exec("clear") } catch (e) { try { exec("cls") } catch (e2) { } } return null }
std.terminal.clear = term_clear

// ---- 36 scheduler ------------------------------------------------------
std.scheduler = {}
fn schedule_sleep_then(ms, fnname) { _sleep_ms(ms); if fnname == null { return null } let f = null; try { f = global_get(fnname) } catch (e) { f = null } if f { try { f() } catch (e2) { } } return null }
std.scheduler.sleep_then = schedule_sleep_then

// ---- 37 compression (stubs) --------------------------------------------
std.compress = {}
fn compress_stub(s) { return s }
fn decompress_stub(s) { return s }
std.compress.compress = compress_stub
std.compress.decompress = decompress_stub

// ---- 38 encoding -------------------------------------------------------
std.encoding = {}
fn enc_upper(s) { if s == null { return "" } return toUpper(s) }
fn enc_lower(s) { if s == null { return "" } return toLower(s) }
std.encoding.upper = enc_upper
std.encoding.lower = enc_lower

// ---- 39 math_more ------------------------------------------------------
std.math_more = {}
fn mm_factorial(n) { if n <= 1 { return 1 } let r = 1; let i = 2; while (i <= n) { r = r * i; i = i + 1 } return r }
std.math_more.factorial = mm_factorial

// ---- 40 geometry3d -----------------------------------------------------
std.geometry3d = {}
fn g3d_dist(x1,y1,z1,x2,y2,z2) { let dx = x2 - x1; let dy = y2 - y1; let dz = z2 - z1; return _sqrt(dx*dx + dy*dy + dz*dz) }
std.geometry3d.dist = g3d_dist

// ---- 41 physics_basic --------------------------------------------------
std.physics = {}
fn physics_kinematic_pos(x0, v, t) { return x0 + v * t }
std.physics.kinematic_pos = physics_kinematic_pos

// ---- 42 game_loop ------------------------------------------------------
std.gameloop = {}
fn game_loop_simple(iterations, tick_ms, body_fn_name) { if iterations == null || iterations <= 0 { return null } let i = 0; while (i < iterations) { let f = null; try { f = global_get(body_fn_name) } catch (e) { f = null } if f { try { f(i) } catch (e2) { } } _sleep_ms(tick_ms); i = i + 1 } return null }
std.gameloop.simple = game_loop_simple

// ---- 43 io_helpers -----------------------------------------------------
std.io = {}
fn io_exists(p) { if p == null { return false } try { return exists(p) } catch (e) { return false } }
fn io_delete(p) { if p == null { return null } try { delete(p) } catch (e) { } return null }
std.io.exists = io_exists
std.io.delete = io_delete

// ---- 44 html_builder ---------------------------------------------------
std.html_builder = {}
fn hb_tag(name, content) { if name == null { return "" } if content == null { content = "" } return "<" + name + ">" + content + "</" + name + ">" }
std.html_builder.tag = hb_tag

// ---- 45 color_utils ----------------------------------------------------
std.color_utils = {}
fn color_brightness(hex) { let c = color_hex_to_rgb(hex); return (c.r * 299 + c.g * 587 + c.b * 114) / 1000 }
std.color_utils.brightness = color_brightness

// ---- 46 simple_ai ------------------------------------------------------
std.ai = {}
fn ai_echo(s) { if s == null { return "" } return "ECHO: " + s }
std.ai.echo = ai_echo

// ---- 47 phone ----------------------------------------------------------
std.phone = {}
fn phone_digits(s) { if s == null { return [] } let out = []; let i = 0; let buf = ""; while (i < len(s)) { let ch = substring(s, i, 1); if unicode_is_digit(ch) { buf = buf + ch } else { if len(buf) > 0 { append(out, buf); buf = "" } } i = i + 1 } if len(buf) > 0 { append(out, buf) } return out }
std.phone.digits = phone_digits

// ---- 48 zstring --------------------------------------------------------
std.zstring = {}
fn zpad(n, width) { let s = _to_string(n); while (len(s) < width) { s = "0" + s } return s }
std.zstring.pad = zpad

// ---- 49 misc -----------------------------------------------------------
std.misc = {}
fn misc_now_readable() { return _to_string(time()) }
std.misc.now = misc_now_readable

// ---- 50 dev_helpers ----------------------------------------------------
std.dev = {}
fn dev_print_keys(o) { if o == null { return [] } let out = []; for k in o { append(out, k) } return out }
std.dev.keys = dev_print_keys

// Register std globally if possible
try { global_set("std", std) } catch (e) { }

// Export module
std
