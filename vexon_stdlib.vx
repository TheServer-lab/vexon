// vexon_stdlib.vx
// Patched Vexon Standard Library (50 namespaces)
// - Fixed control-flow syntax to use braces
// - Added defensive checks
// - Avoided fragile fallbacks where possible
// - Registers `std` as a global if `global_set` is available
//
// Save next to your Vexon runtime and import with:
//   import "vexon_stdlib.vx" as std
//
// Note: this file assumes the VM exposes builtins seen in your runtime:
// print, read, write, append, exists, delete, list, mkdir, json_encode, json_decode,
// time, random, toUpper, toLower, substring, split, indexOf, replace, startsWith, endsWith,
// parseInt, join_path, exec, env, set_env, global_set, global_get
//
// If any builtin is missing, adjust the function to avoid it.

let std = {}

// ---------------------------
// 1. string
// ---------------------------
fn string_reverse(s) {
  if s == null { return "" }
  let out = ""
  let i = len(s) - 1
  while (i >= 0) {
    out = out + s[i]
    i = i - 1
  }
  return out
}
fn string_capitalize(s) {
  if s == null { return "" }
  if len(s) == 0 {
    return ""
  }
  let first = substring(s, 0, 1)
  let rest = substring(s, 1)
  return toUpper(first) + rest
}
fn string_repeat(s, n) {
  if s == null { return "" }
  if n <= 0 { return "" }
  let out = ""
  let i = 0
  while (i < n) {
    out = out + s
    i = i + 1
  }
  return out
}
std.string = {}
std.string.reverse = string_reverse
std.string.capitalize = string_capitalize
std.string.repeat = string_repeat

// ---------------------------
// 2. text
// ---------------------------
fn text_bold(s) {
  if s == null { return "" }
  return "**" + s + "**"
}
fn text_italic(s) {
  if s == null { return "" }
  return "*" + s + "*"
}
fn text_code(s) {
  if s == null { return "" }
  return "`" + s + "`"
}
std.text = {}
std.text.bold = text_bold
std.text.italic = text_italic
std.text.code = text_code

// ---------------------------
// 3. search
// ---------------------------
fn search_contains(s, sub) {
  if s == null || sub == null { return false }
  return indexOf(s, sub) != -1
}
fn search_count(s, sub) {
  if s == null || sub == null { return 0 }
  let c = 0
  let i = 0
  let limit = len(s) - len(sub)
  if (limit < 0) { return 0 }
  while (i <= limit) {
    if (substring(s, i, i + len(sub)) == sub) {
      c = c + 1
    }
    i = i + 1
  }
  return c
}
std.search = {}
std.search.contains = search_contains
std.search.count = search_count

// ---------------------------
// 4. unicode
// ---------------------------
fn unicode_is_digit(c) {
  if c == null { return false }
  return c >= "0" && c <= "9"
}
fn unicode_is_alpha(c) {
  if c == null { return false }
  return (c >= "a" && c <= "z") || (c >= "A" && c <= "Z")
}
std.unicode = {}
std.unicode.is_digit = unicode_is_digit
std.unicode.is_alpha = unicode_is_alpha

// ---------------------------
// 5. parse
// ---------------------------
fn parse_bool(s) {
  if s == null { return null }
  let t = toLower(trim(s))
  if t == "true" {
    return true
  }
  if t == "false" {
    return false
  }
  return null
}
fn parse_csv(s) {
  if s == null { return [] }
  return split(s, ",")
}
std.parse = {}
std.parse.bool = parse_bool
std.parse.csv = parse_csv

// ---------------------------
// 6. array
// ---------------------------
fn array_sum(a) {
  if a == null { return 0 }
  let s = 0
  for x in a {
    s = s + x
  }
  return s
}
fn array_avg(a) {
  if a == null { return 0 }
  if len(a) == 0 {
    return 0
  }
  return array_sum(a) / len(a)
}
fn array_max(a) {
  if a == null || len(a) == 0 {
    return null
  }
  let m = a[0]
  for x in a {
    if x > m {
      m = x
    }
  }
  return m
}
std.array = {}
std.array.sum = array_sum
std.array.avg = array_avg
std.array.max = array_max

// ---------------------------
// 7. list_ops
// ---------------------------
fn list_unique(a) {
  if a == null { return [] }
  let out = []
  for x in a {
    let f = false
    for y in out {
      if x == y {
        f = true
        break
      }
    }
    if (!f) {
      push(out, x)
    }
  }
  return out
}
fn list_find(a, v) {
  if a == null { return -1 }
  let i = 0
  while (i < len(a)) {
    if a[i] == v {
      return i
    }
    i = i + 1
  }
  return -1
}
std.list = {}
std.list.unique = list_unique
std.list.find = list_find

// ---------------------------
// 8. sort
// ---------------------------
fn sort_bubble(a) {
  if a == null { return [] }
  let n = len(a)
  let i = 0
  while (i < n) {
    let j = 0
    while (j < n - 1) {
      if a[j] > a[j + 1] {
        let t = a[j]
        a[j] = a[j + 1]
        a[j + 1] = t
      }
      j = j + 1
    }
    i = i + 1
  }
  return a
}
std.sort = {}
std.sort.bubble = sort_bubble

// ---------------------------
// 9. stack
// ---------------------------
let _stack_internal = []
fn stack_push(v) {
  push(_stack_internal, v)
  return null
}
fn stack_pop() {
  if len(_stack_internal) == 0 {
    return null
  }
  return pop(_stack_internal)
}
fn stack_peek() {
  if len(_stack_internal) == 0 {
    return null
  }
  return _stack_internal[len(_stack_internal) - 1]
}
std.stack = {}
std.stack.push = stack_push
std.stack.pop = stack_pop
std.stack.peek = stack_peek

// ---------------------------
// 10. queue
// ---------------------------
let _queue_internal = []
fn queue_enqueue(v) {
  push(_queue_internal, v)
  return null
}
fn queue_dequeue() {
  if len(_queue_internal) == 0 {
    return null
  }
  let out = _queue_internal[0]
  let i = 0
  while (i < len(_queue_internal) - 1) {
    _queue_internal[i] = _queue_internal[i + 1]
    i = i + 1
  }
  pop(_queue_internal)
  return out
}
std.queue = {}
std.queue.enqueue = queue_enqueue
std.queue.dequeue = queue_dequeue

// ---------------------------
// 11. math
// ---------------------------
fn math_clamp(x, a, b) {
  if x < a {
    return a
  }
  if x > b {
    return b
  }
  return x
}
fn math_lerp(a, b, t) {
  return a + (b - a) * t
}
fn math_sign(x) {
  if x > 0 {
    return 1
  }
  if x < 0 {
    return -1
  }
  return 0
}
std.mathx = {}
std.mathx.clamp = math_clamp
std.mathx.lerp = math_lerp
std.mathx.sign = math_sign

// ---------------------------
// 12. geometry
// ---------------------------
fn geom_dist(x1, y1, x2, y2) {
  let dx = x2 - x1
  let dy = y2 - y1
  return math.sqrt(dx * dx + dy * dy)
}
fn geom_area_rect(w, h) {
  return w * h
}
std.geometry = {}
std.geometry.dist = geom_dist
std.geometry.area_rect = geom_area_rect

// ---------------------------
// 13. vector2
// ---------------------------
fn v2_add(a, b) {
  if a == null || b == null { return {x:0, y:0} }
  return { x: a.x + b.x, y: a.y + b.y }
}
fn v2_sub(a, b) {
  if a == null || b == null { return {x:0, y:0} }
  return { x: a.x - b.x, y: a.y - b.y }
}
fn v2_scale(a, s) {
  if a == null { return {x:0, y:0} }
  return { x: a.x * s, y: a.y * s }
}
std.vector2 = {}
std.vector2.add = v2_add
std.vector2.sub = v2_sub
std.vector2.scale = v2_scale

// ---------------------------
// 14. fs
// ---------------------------
fn fs_read_lines(p) {
  if !exists(p) {
    return []
  }
  return split(read(p), "\n")
}
fn fs_write_lines(p, arr) {
  if arr == null { return null }
  let s = ""
  for x in arr {
    s = s + x + "\n"
  }
  write(p, s)
  return null
}
fn fs_copy(a, b) {
  if !exists(a) {
    return null
  }
  write(b, read(a))
  return null
}
std.fs = {}
std.fs.read_lines = fs_read_lines
std.fs.write_lines = fs_write_lines
std.fs.copy = fs_copy

// ---------------------------
// 15. time
// ---------------------------
fn time_now() {
  return time()
}
fn time_sleep_ms(ms) {
  sleep(ms)
  return null
}
fn time_ts() {
  return toString(time())
}
std.time = {}
std.time.now = time_now
std.time.sleep_ms = time_sleep_ms
std.time.ts = time_ts

// ---------------------------
// 16. random
// ---------------------------
fn rnd_int(min, max) {
  if min > max {
    let t = min; min = max; max = t
  }
  return floor(random() * (max - min + 1)) + min
}
fn rnd_choice(a) {
  if a == null || len(a) == 0 {
    return null
  }
  return a[rnd_int(0, len(a) - 1)]
}
fn rnd_shuffle(a) {
  if a == null { return [] }
  let i = len(a) - 1
  while (i > 0) {
    let j = rnd_int(0, i)
    let t = a[i]
    a[i] = a[j]
    a[j] = t
    i = i - 1
  }
  return a
}
std.random = {}
std.random.randint = rnd_int
std.random.choice = rnd_choice
std.random.shuffle = rnd_shuffle

// ---------------------------
// 17. log
// ---------------------------
fn log_write(m) {
  if m == null { m = "" }
  append("vexon.log", "[" + toString(time()) + "] " + m + "\n")
  return null
}
fn log_read_all() {
  if !exists("vexon.log") {
    return ""
  }
  return read("vexon.log")
}
fn log_clear() {
  write("vexon.log", "")
  return null
}
std.log = {}
std.log.write = log_write
std.log.read = log_read_all
std.log.clear = log_clear

// ---------------------------
// 18. env
// ---------------------------
fn env_get(n) {
  if n == null { return env() }
  return env(n)
}
fn env_set(n, v) {
  if n == null { return null }
  set_env(n, v)
  return null
}
std.env = {}
std.env.get = env_get
std.env.set = env_set

// ---------------------------
// 19. json
// ---------------------------
fn json_enc(o) {
  return json_encode(o)
}
fn json_dec(s) {
  return json_decode(s)
}
fn json_save(p, o) {
  write(p, json_encode(o))
  return null
}
fn json_load(p) {
  if !exists(p) {
    return null
  }
  return json_decode(read(p))
}
std.json = {}
std.json.encode = json_enc
std.json.decode = json_dec
std.json.save = json_save
std.json.load = json_load

// ---------------------------
// 20. path
// ---------------------------
fn path_join(a, b) {
  return join_path(a, b)
}
fn path_filename(p) {
  if p == null { return "" }
  let arr = split(p, "/")
  return arr[len(arr) - 1]
}
fn path_ext(p) {
  if p == null { return "" }
  let arr = split(p, ".")
  if len(arr) < 2 {
    return ""
  }
  return arr[len(arr) - 1]
}
std.path = {}
std.path.join = path_join
std.path.filename = path_filename
std.path.ext = path_ext

// ---------------------------
// 21. http (wrapper)
// ---------------------------
fn http_get_json(url) {
  if url == null { return null }
  return http_get(url)
}
fn http_post_json(url, payload) {
  if url == null { return null }
  return http_post(url, payload)
}
std.http = {}
std.http.get = http_get_json
std.http.post = http_post_json

// ---------------------------
// 22. net (tiny helpers)
// ---------------------------
fn net_ping(url) {
  if url == null { return false }
  try {
    let r = http_get(url)
    return true
  } catch (e) {
    return false
  }
}
std.net = {}
std.net.ping = net_ping

// ---------------------------
// 23. base64 (simple wrapper)
// ---------------------------
// Use exec to call node Buffer if available; otherwise return null (explicit)
fn b64_encode_js(s) {
  if s == null { return null }
  try {
    // exec may return stdout or may be void depending on runtime; attempt and return null on failure
    let cmd = "node -e \"console.log(Buffer.from(" + json_encode(s) + ").toString('base64'))\""
    let out = exec(cmd)
    return out
  } catch (e) {
    return null
  }
}
std.base64 = {}
std.base64.encode = b64_encode_js

// ---------------------------
// 24. uuid (very simple)
// ---------------------------
fn uuid_v4_like() {
  let a = ""
  let i = 0
  while (i < 32) {
    let n = rnd_int(0, 15)
    let h = "0123456789abcdef"[n]
    a = a + h
    i = i + 1
  }
  return substring(a, 0, 8) + "-" + substring(a, 8, 12) + "-" + substring(a, 12, 16) + "-" + substring(a, 16, 20) + "-" + substring(a, 20, 32)
}
std.uuid = {}
std.uuid.v4 = uuid_v4_like

// ---------------------------
// 25. csv
// ---------------------------
fn csv_parse(text) {
  if text == null { return [] }
  let lines = split(text, "\n")
  let out = []
  for l in lines {
    if len(trim(l)) == 0 {
      continue
    }
    push(out, split(l, ","))
  }
  return out
}
fn csv_stringify(arr) {
  if arr == null { return "" }
  let out = ""
  for r in arr {
    let i = 0
    let line = ""
    while (i < len(r)) {
      line = line + toString(r[i]) + (i < len(r) - 1 ? "," : "")
      i = i + 1
    }
    out = out + line + "\n"
  }
  return out
}
std.csv = {}
std.csv.parse = csv_parse
std.csv.stringify = csv_stringify

// ---------------------------
// 26. validators
// ---------------------------
fn is_email(s) {
  if s == null { return false }
  return indexOf(s, "@") != -1 && indexOf(s, ".") != -1
}
fn is_url(s) {
  if s == null { return false }
  return startsWith(s, "http://") || startsWith(s, "https://")
}
std.validators = {}
std.validators.email = is_email
std.validators.url = is_url

// ---------------------------
// 27. stopwatch
// ---------------------------
fn sw_start() {
  return time()
}
fn sw_elapsed(start) {
  if start == null { return 0 }
  return time() - start
}
std.stopwatch = {}
std.stopwatch.start = sw_start
std.stopwatch.elapsed = sw_elapsed

// ---------------------------
// 28. stats
// ---------------------------
fn stats_mean(a) {
  if a == null || len(a) == 0 { return null }
  return array_sum(a) / len(a)
}
fn stats_variance(a) {
  let m = stats_mean(a)
  if m == null { return null }
  let s = 0
  for x in a {
    s = s + (x - m) * (x - m)
  }
  return s / len(a)
}
std.stats = {}
std.stats.mean = stats_mean
std.stats.variance = stats_variance

// ---------------------------
// 29. matrix (basic)
// ---------------------------
fn mat_mul_vec(mat, vec) {
  if mat == null || vec == null { return [] }
  let out = []
  let i = 0
  while (i < len(mat)) {
    let row = mat[i]
    let s = 0
    let j = 0
    while (j < len(row)) {
      s = s + row[j] * vec[j]
      j = j + 1
    }
    push(out, s)
    i = i + 1
  }
  return out
}
std.matrix = {}
std.matrix.mul_vec = mat_mul_vec

// ---------------------------
// 30. data (key-value simple db)
// ---------------------------
fn kv_set(path, key, val) {
  if path == null { return null }
  let store = {}
  if exists(path) {
    store = json_decode(read(path))
  }
  store[key] = val
  write(path, json_encode(store))
  return null
}
fn kv_get(path, key) {
  if path == null || !exists(path) {
    return null
  }
  let store = json_decode(read(path))
  return store[key]
}
std.kv = {}
std.kv.set = kv_set
std.kv.get = kv_get

// ---------------------------
// 31. serializer (tiny)
// ---------------------------
fn ser_to_json(o) { return json_encode(o) }
fn ser_from_json(s) { return json_decode(s) }
std.serializer = {}
std.serializer.to_json = ser_to_json
std.serializer.from_json = ser_from_json

// ---------------------------
// 32. html_utils
// ---------------------------
fn html_escape(s) {
  if s == null { return "" }
  let out = s
  out = replace(out, "&", "&amp;")
  out = replace(out, "<", "&lt;")
  out = replace(out, ">", "&gt;")
  out = replace(out, "\"", "&quot;")
  return out
}
std.html = {}
std.html.escape = html_escape

// ---------------------------
// 33. shell (exec helpers)
// ---------------------------
fn sh_exec(cmd) {
  if cmd == null { return null }
  try {
    return exec(cmd)
  } catch (e) {
    return null
  }
}
fn sh_capture(cmd) {
  if cmd == null { return null }
  try {
    return exec(cmd)
  } catch (e) {
    return null
  }
}
std.shell = {}
std.shell.exec = sh_exec
std.shell.capture = sh_capture

// ---------------------------
// 34. colors (basic)
// ---------------------------
fn color_hex_to_rgb(hex) {
  if hex == null { return {r:0,g:0,b:0} }
  if startsWith(hex, "#") {
    hex = substring(hex, 1)
  }
  if len(hex) < 6 {
    return { r: 0, g: 0, b: 0 }
  }
  let r = parseInt(substring(hex, 0, 2), 16)
  let g = parseInt(substring(hex, 2, 4), 16)
  let b = parseInt(substring(hex, 4, 6), 16)
  return { r: r, g: g, b: b }
}
std.color = {}
std.color.hex_to_rgb = color_hex_to_rgb

// ---------------------------
// 35. terminal (tiny styling)
// ---------------------------
fn term_clear() {
  try {
    exec("clear")
  } catch (e) {
    try {
      exec("cls")
    } catch (e2) {
      // ignore
    }
  }
  return null
}
std.terminal = {}
std.terminal.clear = term_clear

// ---------------------------
// 36. scheduler (very simple)
// ---------------------------
fn schedule_sleep_then(ms, fnname) {
  sleep(ms)
  if fnname == null { return null }
  let f = null
  try {
    f = global_get(fnname)
  } catch (e) {
    f = null
  }
  if f {
    try {
      f()
    } catch (e2) {
      // ignore
    }
  }
  return null
}
std.scheduler = {}
std.scheduler.sleep_then = schedule_sleep_then

// ---------------------------
// 37. compression (placeholder)
// ---------------------------
fn compress_stub(s) { return s }
fn decompress_stub(s) { return s }
std.compress = {}
std.compress.compress = compress_stub
std.compress.decompress = decompress_stub

// ---------------------------
// 38. encoding (utf helpers)
// ---------------------------
fn enc_upper(s) {
  if s == null { return "" }
  return toUpper(s)
}
fn enc_lower(s) {
  if s == null { return "" }
  return toLower(s)
}
std.encoding = {}
std.encoding.upper = enc_upper
std.encoding.lower = enc_lower

// ---------------------------
// 39. math_more
// ---------------------------
fn mm_factorial(n) {
  if n <= 1 {
    return 1
  }
  let r = 1
  let i = 2
  while (i <= n) {
    r = r * i
    i = i + 1
  }
  return r
}
std.math_more = {}
std.math_more.factorial = mm_factorial

// ---------------------------
// 40. geometry3d (basic)
// ---------------------------
fn g3d_dist(x1, y1, z1, x2, y2, z2) {
  let dx = x2 - x1
  let dy = y2 - y1
  let dz = z2 - z1
  return math.sqrt(dx * dx + dy * dy + dz * dz)
}
std.geometry3d = {}
std.geometry3d.dist = g3d_dist

// ---------------------------
// 41. physics_basic
// ---------------------------
fn physics_kinematic_pos(x0, v, t) {
  return x0 + v * t
}
std.physics = {}
std.physics.kinematic_pos = physics_kinematic_pos

// ---------------------------
// 42. game_loop (very small)
// ---------------------------
fn game_loop_simple(iterations, tick_ms, body_fn_name) {
  if iterations == null || iterations <= 0 { return null }
  let i = 0
  while (i < iterations) {
    let f = null
    try {
      f = global_get(body_fn_name)
    } catch (e) {
      f = null
    }
    if f {
      try {
        f(i)
      } catch (e2) {
        // ignore
      }
    }
    sleep(tick_ms)
    i = i + 1
  }
  return null
}
std.gameloop = {}
std.gameloop.simple = game_loop_simple

// ---------------------------
// 43. io_helpers
// ---------------------------
fn io_exists(p) {
  if p == null { return false }
  return exists(p)
}
fn io_delete(p) {
  if p == null { return null }
  delete(p)
  return null
}
std.io = {}
std.io.exists = io_exists
std.io.delete = io_delete

// ---------------------------
// 44. html_builder
// ---------------------------
fn hb_tag(name, content) {
  if name == null { return "" }
  if content == null { content = "" }
  return "<" + name + ">" + content + "</" + name + ">"
}
std.html_builder = {}
std.html_builder.tag = hb_tag

// ---------------------------
// 45. color_utils
// ---------------------------
fn color_brightness(hex) {
  let c = color_hex_to_rgb(hex)
  return (c.r * 299 + c.g * 587 + c.b * 114) / 1000
}
std.color_utils = {}
std.color_utils.brightness = color_brightness

// ---------------------------
// 46. simple_ai (toy)
// ---------------------------
fn ai_echo(s) {
  if s == null { return "" }
  return "ECHO: " + s
}
std.ai = {}
std.ai.echo = ai_echo

// ---------------------------
// 47. phone (formatting)
// ---------------------------
fn phone_digits(s) {
  if s == null { return [] }
  return split(s, ",")
}
std.phone = {}
std.phone.digits = phone_digits

// ---------------------------
// 48. zstring (zero-pad)
// ---------------------------
fn zpad(n, width) {
  let s = toString(n)
  while (len(s) < width) {
    s = "0" + s
  }
  return s
}
std.zstring = {}
std.zstring.pad = zpad

// ---------------------------
// 49. misc
// ---------------------------
fn misc_now_readable() {
  return toString(time())
}
std.misc = {}
std.misc.now = misc_now_readable

// ---------------------------
// 50. dev_helpers
// ---------------------------
fn dev_print_keys(o) {
  if o == null { return [] }
  let out = []
  for k in o {
    push(out, k)
  }
  return out
}
std.dev = {}
std.dev.keys = dev_print_keys

// Register std as a global if possible so importers can access it reliably
try {
  global_set("std", std)
} catch (e) {
  // ignore if global_set not available
}

// Return std as module export
std
